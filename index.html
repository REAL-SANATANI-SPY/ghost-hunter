<!-- Ghost Hunter ‚Äì created by [REAL SPY/sanatani spy] (2025) -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Ghost Hunter ¬∑ Settings Dropdown</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
        }

        body {
            background: #0b0722;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', Roboto, system-ui, sans-serif;
            touch-action: none;
            padding: 0;
            position: fixed;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            max-width: 1200px;
            border-radius: 0;
            background: rgba(20, 10, 35, 0.5);
            backdrop-filter: blur(12px);
            box-shadow: 0 30px 40px rgba(0, 0, 0, 0.6), 0 0 30px #9f7aff80;
            padding: 10px;
            border: none;
            position: relative;
        }

        /* Top bar with stats */
        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 10px;
            gap: 10px;
        }

        .stats-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex: 2;
            padding: 8px 15px;
            background: rgba(10, 5, 20, 0.7);
            backdrop-filter: blur(8px);
            border-radius: 40px;
            border: 1px solid #a07dff;
            box-shadow: 0 4px 10px #3a236a;
            color: white;
            font-weight: bold;
            font-size: 1rem;
            text-shadow: 0 2px 5px #00000080;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(255,255,255,0.1);
            padding: 4px 12px;
            border-radius: 30px;
            backdrop-filter: blur(4px);
        }

        .stat-icon {
            font-size: 1.2rem;
            filter: drop-shadow(0 0 6px cyan);
        }

        /* Settings Dropdown - NEW */
        .settings-container {
            position: relative;
            flex: 1;
            display: flex;
            justify-content: flex-end;
            z-index: 100;
        }

        .settings-toggle {
            background: rgba(10, 5, 20, 0.7);
            backdrop-filter: blur(8px);
            border: 1px solid #a07dff;
            color: white;
            padding: 8px 20px;
            border-radius: 40px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 10px #3a236a;
            transition: all 0.2s;
        }

        .settings-toggle:hover {
            background: rgba(30, 15, 50, 0.8);
            border-color: #c7a6ff;
        }

        .settings-toggle.active {
            background: #6a4cc7;
            border-color: white;
        }

        .settings-dropdown {
            position: absolute;
            top: 50px;
            right: 0;
            width: 280px;
            background: rgba(15, 8, 30, 0.95);
            backdrop-filter: blur(12px);
            border: 2px solid #9f7aff;
            border-radius: 24px;
            padding: 15px;
            color: white;
            box-shadow: 0 15px 30px black, 0 0 30px #9f7aff;
            display: none;
            z-index: 200;
        }

        .settings-dropdown.show {
            display: block;
        }

        .settings-header {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 15px;
            color: #c7a6ff;
            text-align: center;
            border-bottom: 1px solid #4b3b6b;
            padding-bottom: 8px;
        }

        .setting-group {
            margin-bottom: 20px;
        }

        .setting-group h3 {
            font-size: 0.9rem;
            color: #b3a0ff;
            margin-bottom: 8px;
            font-weight: normal;
            letter-spacing: 1px;
        }

        .setting-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .setting-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: rgba(255,255,255,0.05);
            border-radius: 30px;
            border: 1px solid rgba(160, 125, 255, 0.3);
            cursor: pointer;
            transition: all 0.2s;
        }

        .setting-option:hover {
            background: rgba(160, 125, 255, 0.2);
            border-color: #a07dff;
        }

        .setting-option.selected {
            background: rgba(160, 125, 255, 0.3);
            border-color: #c7a6ff;
            box-shadow: 0 0 10px #9f7aff;
        }

        .setting-option input[type="radio"] {
            appearance: none;
            width: 16px;
            height: 16px;
            border: 2px solid #a07dff;
            border-radius: 50%;
            margin: 0;
            position: relative;
            cursor: pointer;
        }

        .setting-option input[type="radio"]:checked {
            background: #c7a6ff;
            border-color: white;
            box-shadow: 0 0 8px #c7a6ff;
        }

        .setting-option input[type="radio"]:checked::after {
            content: '';
            position: absolute;
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
        }

        .option-label {
            flex: 1;
            font-size: 0.9rem;
        }

        .option-desc {
            font-size: 0.7rem;
            color: #b3a0ff;
            margin-top: 2px;
        }

        /* Canvas container */
        .canvas-container {
            position: relative;
            width: 100%;
            flex: 1;
            display: flex;
            justify-content: center;
            border-radius: 24px;
            overflow: hidden;
            box-shadow: 0 10px 20px black, 0 0 0 2px #b380ff, 0 0 15px #b57cff;
            min-height: 0;
            background: #141024;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: #141024;
            touch-action: none;
        }

        /* Joystick */
        .joystick-area {
            position: absolute;
            bottom: 15px;
            left: 15px;
            width: 100px;
            height: 100px;
            border-radius: 50px;
            background: rgba(20, 10, 35, 0.5);
            backdrop-filter: blur(8px);
            border: 2px solid rgba(200, 160, 255, 0.6);
            box-shadow: 0 5px 15px #00000099;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
            z-index: 20;
        }

        .joystick-thumb {
            width: 45px;
            height: 45px;
            background: radial-gradient(circle at 30% 30%, #f0e4ff, #9f72e6);
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.9);
            box-shadow: 0 3px 10px black;
            transition: transform 0.02s;
            touch-action: none;
            will-change: transform;
        }

        /* Control buttons */
        .control-buttons {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            gap: 10px;
            z-index: 30;
        }

        .control-btn {
            width: 44px;
            height: 44px;
            border-radius: 22px;
            background: rgba(20, 10, 35, 0.6);
            backdrop-filter: blur(8px);
            border: 2px solid rgba(200, 160, 255, 0.6);
            color: white;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 10px black;
            -webkit-tap-highlight-color: transparent;
        }

        .control-btn:active {
            transform: scale(0.9);
            background: rgba(100, 70, 200, 0.8);
        }

        .restart-btn {
            background: linear-gradient(145deg, #6a4cc7, #402e8b);
            border: none;
            color: white;
            font-size: 1.3rem;
            font-weight: bold;
            padding: 12px 30px;
            border-radius: 40px;
            margin: 10px 0;
            box-shadow: 0 8px 0 #2b1b5a, 0 5px 15px black;
            cursor: pointer;
            transition: 0.08s linear;
            border: 2px solid #c7a6ff;
            letter-spacing: 1px;
            display: none;
            z-index: 40;
        }

        .restart-btn:active {
            transform: translateY(5px);
            box-shadow: 0 3px 0 #2b1b5a, 0 5px 15px black;
        }

        .restart-btn.visible {
            display: block;
        }

        /* Rotation overlay */
        .rotate-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #0b0722;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            color: white;
            text-align: center;
            padding: 20px;
            flex-direction: column;
        }

        .rotate-overlay.show {
            display: flex;
        }

        .rotate-icon {
            font-size: 4rem;
            animation: rotate 2s infinite;
            margin-bottom: 20px;
        }

        @keyframes rotate {
            0% { transform: rotate(0deg); }
            25% { transform: rotate(90deg); }
            50% { transform: rotate(180deg); }
            75% { transform: rotate(270deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 600px) {
            .top-bar { flex-direction: column; align-items: stretch; }
            .stats-panel { font-size: 0.9rem; padding: 6px 10px; }
            .stat-item { padding: 3px 8px; }
            .settings-dropdown { width: 250px; right: 0; }
            .joystick-area { width: 80px; height: 80px; bottom: 10px; left: 10px; }
            .joystick-thumb { width: 35px; height: 35px; }
            .control-btn { width: 40px; height: 40px; font-size: 1.1rem; }
        }
    </style>
</head>
<body>
    <!-- Rotation warning overlay -->
    <div class="rotate-overlay" id="rotateOverlay">
        <div class="rotate-icon">üîÑ</div>
        <h2>Please rotate your device</h2>
        <p>This game works best in landscape mode</p>
    </div>

    <div class="game-wrapper">
        <!-- Top bar with stats and settings -->
        <div class="top-bar">
            <div class="stats-panel">
                <div class="stat-item"><span class="stat-icon">üèÜ</span> <span id="scoreDisplay">0</span></div>
                <div class="stat-item"><span class="stat-icon">üßÇ</span> <span id="saltDisplay">10</span></div>
                <div class="stat-item"><span class="stat-icon">‚ù§Ô∏è</span> <span id="healthDisplay">5/5</span></div>
            </div>

            <!-- Settings Dropdown -->
            <div class="settings-container">
                <button class="settings-toggle" id="settingsToggle">‚öôÔ∏è SETTINGS ‚ñº</button>
                <div class="settings-dropdown" id="settingsDropdown">
                    <div class="settings-header">GAME SETTINGS</div>
                    
                    <!-- Difficulty Options -->
                    <div class="setting-group">
                        <h3>DIFFICULTY</h3>
                        <div class="setting-options">
                            <label class="setting-option" id="difficultyEasy">
                                <input type="radio" name="difficulty" value="easy">
                                <div class="option-label">
                                    Easy
                                    <div class="option-desc">40% speed ‚Ä¢ Relaxed</div>
                                </div>
                            </label>
                            <label class="setting-option" id="difficultyMedium">
                                <input type="radio" name="difficulty" value="medium" checked>
                                <div class="option-label">
                                    Medium
                                    <div class="option-desc">70% speed ‚Ä¢ Balanced</div>
                                </div>
                            </label>
                            <label class="setting-option" id="difficultyHard">
                                <input type="radio" name="difficulty" value="hard">
                                <div class="option-label">
                                    Hard
                                    <div class="option-desc">100% speed ‚Ä¢ Challenging</div>
                                </div>
                            </label>
                        </div>
                    </div>

                    <!-- Aim Mode Options -->
                    <div class="setting-group">
                        <h3>AIM MODE</h3>
                        <div class="setting-options">
                            <label class="setting-option" id="aimManual">
                                <input type="radio" name="aimMode" value="manual">
                                <div class="option-label">
                                    Manual
                                    <div class="option-desc">Drag to aim direction</div>
                                </div>
                            </label>
                            <label class="setting-option" id="aimAuto">
                                <input type="radio" name="aimMode" value="auto">
                                <div class="option-label">
                                    Auto-aim
                                    <div class="option-desc">Target nearest ghost</div>
                                </div>
                            </label>
                            <label class="setting-option" id="aimMixed">
                                <input type="radio" name="aimMode" value="mixed" checked>
                                <div class="option-label">
                                    Mixed
                                    <div class="option-desc">Drag or tap enemies</div>
                                </div>
                            </label>
                        </div>
                    </div>

                    <!-- Cursor Style (Desktop) -->
                    <div class="setting-group">
                        <h3>CURSOR STYLE (DESKTOP)</h3>
                        <div class="setting-options">
                            <label class="setting-option" id="cursorCrosshair">
                                <input type="radio" name="cursorStyle" value="crosshair" checked>
                                <div class="option-label">
                                    Crosshair
                                    <div class="option-desc">‚ûï Precise aiming</div>
                                </div>
                            </label>
                            <label class="setting-option" id="cursorScope">
                                <input type="radio" name="cursorStyle" value="scope">
                                <div class="option-label">
                                    Scope
                                    <div class="option-desc">‚óé Circle reticle</div>
                                </div>
                            </label>
                            <label class="setting-option" id="cursorDot">
                                <input type="radio" name="cursorStyle" value="dot">
                                <div class="option-label">
                                    Dot
                                    <div class="option-desc">‚Ä¢ Simple dot</div>
                                </div>
                            </label>
                            <label class="setting-option" id="cursorNone">
                                <input type="radio" name="cursorStyle" value="none">
                                <div class="option-label">
                                    None
                                    <div class="option-desc">No cursor</div>
                                </div>
                            </label>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            
            <!-- Virtual joystick -->
            <div class="joystick-area" id="joystickBase">
                <div class="joystick-thumb" id="joystickThumb"></div>
            </div>

            <!-- Control buttons -->
            <div class="control-buttons">
                <button class="control-btn" id="fullscreenBtn" aria-label="Fullscreen">‚õ∂</button>
            </div>
        </div>

        <button class="restart-btn" id="restartButton">‚Üª PLAY AGAIN</button>
    </div>

<script>
(function() {
    // Check orientation
    function checkOrientation() {
        const overlay = document.getElementById('rotateOverlay');
        if (window.innerHeight > window.innerWidth) {
            overlay.classList.add('show');
        } else {
            overlay.classList.remove('show');
        }
    }
    
    window.addEventListener('resize', checkOrientation);
    window.addEventListener('orientationchange', checkOrientation);
    checkOrientation();

    // Settings Dropdown Toggle
    const settingsToggle = document.getElementById('settingsToggle');
    const settingsDropdown = document.getElementById('settingsDropdown');
    
    function toggleSettings(e) {
        e.stopPropagation();
        settingsDropdown.classList.toggle('show');
        settingsToggle.classList.toggle('active');
    }
    
    settingsToggle.addEventListener('click', toggleSettings);
    settingsToggle.addEventListener('touchstart', (e) => {
        e.preventDefault();
        toggleSettings(e);
    });
    
    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
        if (!settingsToggle.contains(e.target) && !settingsDropdown.contains(e.target)) {
            settingsDropdown.classList.remove('show');
            settingsToggle.classList.remove('active');
        }
    });
    
    document.addEventListener('touchstart', (e) => {
        if (!settingsToggle.contains(e.target) && !settingsDropdown.contains(e.target)) {
            settingsDropdown.classList.remove('show');
            settingsToggle.classList.remove('active');
        }
    });

    // Fullscreen functionality
    const fullscreenBtn = document.getElementById('fullscreenBtn');
    
    fullscreenBtn.addEventListener('click', toggleFullscreen);
    fullscreenBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        toggleFullscreen();
    });

    function toggleFullscreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => {
                console.log('Fullscreen failed:', err);
            });
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        }
    }

    document.addEventListener('fullscreenchange', updateFullscreenButton);
    document.addEventListener('webkitfullscreenchange', updateFullscreenButton);
    
    function updateFullscreenButton() {
        if (document.fullscreenElement) {
            fullscreenBtn.textContent = '‚úï';
            fullscreenBtn.style.background = 'rgba(200, 70, 70, 0.8)';
        } else {
            fullscreenBtn.textContent = '‚õ∂';
            fullscreenBtn.style.background = 'rgba(20, 10, 35, 0.6)';
        }
    }

    // ---------- SETTINGS HANDLING ----------
    // Difficulty
    const difficultyEasy = document.getElementById('difficultyEasy');
    const difficultyMedium = document.getElementById('difficultyMedium');
    const difficultyHard = document.getElementById('difficultyHard');
    
    // Aim Mode
    const aimManual = document.getElementById('aimManual');
    const aimAuto = document.getElementById('aimAuto');
    const aimMixed = document.getElementById('aimMixed');
    
    // Cursor Style
    const cursorCrosshair = document.getElementById('cursorCrosshair');
    const cursorScope = document.getElementById('cursorScope');
    const cursorDot = document.getElementById('cursorDot');
    const cursorNone = document.getElementById('cursorNone');
    
    // Settings values
    let currentDifficulty = 'medium';
    let currentAimMode = 'mixed';
    let currentCursorStyle = 'crosshair';
    
    // Speed multipliers
    const DIFFICULTY_SETTINGS = {
        easy: { multiplier: 0.4, name: 'Easy' },
        medium: { multiplier: 0.7, name: 'Medium' },
        hard: { multiplier: 1.0, name: 'Hard' }
    };
    
    // Handle difficulty selection
    function setDifficulty(level) {
        currentDifficulty = level;
        document.querySelectorAll('input[name="difficulty"]').forEach(radio => {
            radio.checked = (radio.value === level);
        });
        
        // Update selected visual
        [difficultyEasy, difficultyMedium, difficultyHard].forEach(opt => {
            opt.classList.remove('selected');
        });
        if (level === 'easy') difficultyEasy.classList.add('selected');
        else if (level === 'medium') difficultyMedium.classList.add('selected');
        else difficultyHard.classList.add('selected');
        
        // Restart game with new difficulty
        if (game) {
            game = new Game();
            restartBtn.classList.remove('visible');
        }
    }
    
    // Handle aim mode selection
    function setAimMode(mode) {
        currentAimMode = mode;
        document.querySelectorAll('input[name="aimMode"]').forEach(radio => {
            radio.checked = (radio.value === mode);
        });
        
        // Update selected visual
        [aimManual, aimAuto, aimMixed].forEach(opt => {
            opt.classList.remove('selected');
        });
        if (mode === 'manual') aimManual.classList.add('selected');
        else if (mode === 'auto') aimAuto.classList.add('selected');
        else aimMixed.classList.add('selected');
    }
    
    // Handle cursor style selection
    function setCursorStyle(style) {
        currentCursorStyle = style;
        document.querySelectorAll('input[name="cursorStyle"]').forEach(radio => {
            radio.checked = (radio.value === style);
        });
        
        // Update selected visual
        [cursorCrosshair, cursorScope, cursorDot, cursorNone].forEach(opt => {
            opt.classList.remove('selected');
        });
        if (style === 'crosshair') cursorCrosshair.classList.add('selected');
        else if (style === 'scope') cursorScope.classList.add('selected');
        else if (style === 'dot') cursorDot.classList.add('selected');
        else cursorNone.classList.add('selected');
    }
    
    // Add click handlers for setting options
    difficultyEasy.addEventListener('click', () => setDifficulty('easy'));
    difficultyMedium.addEventListener('click', () => setDifficulty('medium'));
    difficultyHard.addEventListener('click', () => setDifficulty('hard'));
    
    aimManual.addEventListener('click', () => setAimMode('manual'));
    aimAuto.addEventListener('click', () => setAimMode('auto'));
    aimMixed.addEventListener('click', () => setAimMode('mixed'));
    
    cursorCrosshair.addEventListener('click', () => setCursorStyle('crosshair'));
    cursorScope.addEventListener('click', () => setCursorStyle('scope'));
    cursorDot.addEventListener('click', () => setCursorStyle('dot'));
    cursorNone.addEventListener('click', () => setCursorStyle('none'));

    // ---------- GAME CONSTANTS ----------
    const WIDTH = 800, HEIGHT = 600;
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreSpan = document.getElementById('scoreDisplay');
    const saltSpan = document.getElementById('saltDisplay');
    const healthSpan = document.getElementById('healthDisplay');
    const restartBtn = document.getElementById('restartButton');

    // Colors
    const SAFFRON = '#ff9933';
    const BLACK = '#222222';
    const BLUE = '#3a7bd5';
    const RED = '#e63946';
    const PURPLE = '#9d4edd';
    const SILVER = '#cccccc';
    const WHITE = '#ffffff';
    const HEALTH_GREEN = '#2ecc71';
    const SALT_COLOR = '#e0e0ff';
    const BACKGROUND = '#1e1a2e';
    const WALL_COLOR = '#4b3b6b';
    const WALL_BORDER = '#2d1f44';

    // Walls
    const walls = [
        { x: 0, y: 0, w: 800, h: 20 },
        { x: 0, y: 580, w: 800, h: 20 },
        { x: 0, y: 0, w: 20, h: 600 },
        { x: 780, y: 0, w: 20, h: 600 },
        { x: 200, y: 20, w: 20, h: 400 },
        { x: 400, y: 180, w: 20, h: 400 },
        { x: 600, y: 20, w: 20, h: 400 }
    ];

    function rectCollide(r1, r2) {
        return !(r2.x >= r1.x + r1.w || r2.x + r2.w <= r1.x || r2.y >= r1.y + r1.h || r2.y + r2.h <= r1.y);
    }

    const MAX_GHOSTS = 8;

    // ---------- BASE GHOST CLASS WITH DIFFICULTY ----------
    class Ghost {
        constructor(x, y, radius, baseSpeed, damage, points, color) {
            this.x = x; 
            this.y = y; 
            this.radius = radius; 
            
            // Apply difficulty multiplier to speed
            const multiplier = DIFFICULTY_SETTINGS[currentDifficulty].multiplier;
            this.speed = baseSpeed * multiplier;
            
            this.damage = damage; 
            this.points = points; 
            this.color = color;
        }
        update(playerX, playerY) {
            let dx = playerX - this.x;
            let dy = playerY - this.y;
            let dist = Math.hypot(dx, dy) || 0.1;
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;
            this.x = Math.max(this.radius, Math.min(WIDTH - this.radius, this.x));
            this.y = Math.max(this.radius, Math.min(HEIGHT - this.radius, this.y));
        }
        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, 2*Math.PI);
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.fillStyle = WHITE;
            ctx.beginPath(); ctx.arc(this.x-5, this.y-5, 3, 0, 2*Math.PI); ctx.fill();
            ctx.beginPath(); ctx.arc(this.x+5, this.y-5, 3, 0, 2*Math.PI); ctx.fill();
        }
        checkCollision(player) {
            return Math.hypot(this.x - player.x, this.y - player.y) < this.radius + player.radius;
        }
    }
    
    class BlackGhost extends Ghost { 
        constructor(x,y) { 
            super(x,y,15,2.0,1,1,BLACK); 
        } 
    }
    
    class BlueGhost extends Ghost { 
        constructor(x,y) { 
            super(x,y,12,3.2,0.5,2,BLUE); 
        } 
    }

    // Bosses with difficulty
    class Boss {
        constructor(x,y,radius,baseSpeed,damage,health,points,color,dustCooldown,dustRadius,dustDamage) {
            this.x=x; this.y=y; this.radius=radius; 
            
            const multiplier = DIFFICULTY_SETTINGS[currentDifficulty].multiplier;
            this.speed = baseSpeed * multiplier;
            
            this.damage=damage;
            this.health=health; 
            this.maxHealth=health; 
            this.points=points; 
            this.color=color;
            this.dustCooldown=dustCooldown; 
            this.dustTimer=Math.floor(Math.random()*dustCooldown);
            this.dustRadius=dustRadius; 
            this.dustDamage=dustDamage;
        }
        update(playerX, playerY) {
            let dx = playerX - this.x, dy = playerY - this.y;
            let dist = Math.hypot(dx, dy) || 0.1;
            this.x += (dx/dist)*this.speed;
            this.y += (dy/dist)*this.speed;
            this.x = Math.max(this.radius, Math.min(WIDTH-this.radius, this.x));
            this.y = Math.max(this.radius, Math.min(HEIGHT-this.radius, this.y));
            this.dustTimer++;
        }
        draw() {
            ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, 2*Math.PI); ctx.fillStyle = this.color; ctx.fill();
            ctx.fillStyle = '#ffd966';
            ctx.beginPath();
            ctx.moveTo(this.x-25, this.y-this.radius-5);
            ctx.lineTo(this.x-15, this.y-this.radius-15);
            ctx.lineTo(this.x, this.y-this.radius-20);
            ctx.lineTo(this.x+15, this.y-this.radius-15);
            ctx.lineTo(this.x+25, this.y-this.radius-5);
            ctx.closePath(); ctx.fill();

            const barW=60, barH=8;
            ctx.fillStyle='#330000'; ctx.fillRect(this.x-barW/2, this.y-this.radius-25, barW, barH);
            ctx.fillStyle=RED; ctx.fillRect(this.x-barW/2, this.y-this.radius-25, barW*(this.health/this.maxHealth), barH);

            if (this.dustTimer >= this.dustCooldown-30) {
                ctx.beginPath(); ctx.arc(this.x, this.y, this.dustRadius, 0, 2*Math.PI); ctx.strokeStyle=SILVER; ctx.lineWidth=2; ctx.stroke();
            }
        }
        checkCollision(p) { return Math.hypot(this.x-p.x, this.y-p.y) < this.radius+p.radius; }
        canUseDust() { return this.dustTimer >= this.dustCooldown; }
        useDust() { this.dustTimer = 0; }
        checkDustHit(p) { return Math.hypot(this.x-p.x, this.y-p.y) < this.dustRadius; }
    }
    class RedBoss extends Boss { constructor(x,y) { super(x,y,35,1.5,1.0,10,10,RED,120,150,1.5); } }
    class PurpleBoss extends Boss { constructor(x,y) { let h = Math.floor(Math.random()*6)+15; super(x,y,40,1.8,1.0,h,20,PURPLE,100,150,1.5); } }

    // Salt Projectile
    class SaltProjectile {
        constructor(x,y,dx,dy) { this.x=x; this.y=y; this.dx=dx; this.dy=dy; this.radius=5; this.speed=8; this.active=true; }
        update() { this.x+=this.dx*this.speed; this.y+=this.dy*this.speed; if (this.x<-50||this.x>WIDTH+50||this.y<-50||this.y>HEIGHT+50) this.active=false; }
        draw() { ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,2*Math.PI); ctx.fillStyle=SALT_COLOR; ctx.fill(); }
    }

    // Pickup
    class Pickup {
        constructor(x,y,type) { this.x=x; this.y=y; this.radius=10; this.type=type; this.color=type==='salt'?SALT_COLOR:HEALTH_GREEN; }
        draw() {
            ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,2*Math.PI); ctx.fillStyle=this.color; ctx.fill();
            ctx.fillStyle=WHITE; ctx.font='bold 14px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
            if (this.type==='health') ctx.fillText('+',this.x,this.y-1); else ctx.fillText('S',this.x,this.y-1);
        }
        checkCollision(p) { return Math.hypot(this.x-p.x,this.y-p.y) < this.radius+p.radius; }
    }

    // Mobile shooting
    let shootTouchId = null;
    let lastTouchX = -1, lastTouchY = -1;
    let aimDirection = { x: 0, y: -1 }; // Default aim up

    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (game.state !== 'playing' && game.state !== 'final_round') return;
        
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        const canvasX = (touch.clientX - rect.left) * scaleX;
        const canvasY = (touch.clientY - rect.top) * scaleY;
        
        // Check if touch is NOT on joystick area
        const joystickRect = document.getElementById('joystickBase').getBoundingClientRect();
        const isOnJoystick = (
            touch.clientX >= joystickRect.left && 
            touch.clientX <= joystickRect.right && 
            touch.clientY >= joystickRect.top && 
            touch.clientY <= joystickRect.bottom
        );
        
        if (!isOnJoystick) {
            if (currentAimMode === 'manual') {
                // In manual mode, first touch sets aim direction
                shootTouchId = touch.identifier;
                lastTouchX = canvasX;
                lastTouchY = canvasY;
                
                // Update aim direction
                let dx = canvasX - game.player.x;
                let dy = canvasY - game.player.y;
                let len = Math.hypot(dx, dy) || 0.1;
                aimDirection = { x: dx/len, y: dy/len };
            } else if (currentAimMode === 'auto') {
                // Auto-aim: find nearest ghost and shoot
                let nearestGhost = null;
                let nearestDist = Infinity;
                
                const allGhosts = [...game.blackGhosts, ...game.blueGhosts];
                for (let ghost of allGhosts) {
                    let dist = Math.hypot(ghost.x - game.player.x, ghost.y - game.player.y);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestGhost = ghost;
                    }
                }
                
                if (nearestGhost) {
                    let dx = nearestGhost.x - game.player.x;
                    let dy = nearestGhost.y - game.player.y;
                    let len = Math.hypot(dx, dy) || 0.1;
                    game.throwSalt(dx/len, dy/len);
                }
            } else {
                // Mixed mode: treat as manual aim for now
                shootTouchId = touch.identifier;
                lastTouchX = canvasX;
                lastTouchY = canvasY;
                
                let dx = canvasX - game.player.x;
                let dy = canvasY - game.player.y;
                let len = Math.hypot(dx, dy) || 0.1;
                aimDirection = { x: dx/len, y: dy/len };
                game.throwSalt(dx/len, dy/len);
            }
        }
    }, {passive:false});

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (game.state !== 'playing' && game.state !== 'final_round') return;
        
        if (shootTouchId !== null && (currentAimMode === 'manual' || currentAimMode === 'mixed')) {
            for (let i = 0; i < e.touches.length; i++) {
                if (e.touches[i].identifier === shootTouchId) {
                    const touch = e.touches[i];
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    
                    lastTouchX = (touch.clientX - rect.left) * scaleX;
                    lastTouchY = (touch.clientY - rect.top) * scaleY;
                    
                    // Update aim direction
                    let dx = lastTouchX - game.player.x;
                    let dy = lastTouchY - game.player.y;
                    let len = Math.hypot(dx, dy) || 0.1;
                    aimDirection = { x: dx/len, y: dy/len };
                    break;
                }
            }
        }
    }, {passive:false});

    canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        for (let i = 0; i < e.touches.length; i++) {
            if (e.touches[i].identifier === shootTouchId) {
                shootTouchId = null;
                break;
            }
        }
        if (e.touches.length === 0) {
            shootTouchId = null;
        }
    });

    canvas.addEventListener('touchcancel', (e) => {
        e.preventDefault();
        shootTouchId = null;
    });

    // Mouse shooting
    canvas.addEventListener('click', (e) => {
        if (game.state !== 'playing' && game.state !== 'final_round') return;
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const x = (e.clientX - rect.left) * scaleX;
        const y = (e.clientY - rect.top) * scaleY;
        let dx = x - game.player.x;
        let dy = y - game.player.y;
        let len = Math.hypot(dx, dy) || 0.1;
        game.throwSalt(dx/len, dy/len);
    });

    // Player Class
    class Player {
        constructor() {
            this.x = 100; this.y = 100; this.radius = 18; this.speed = 5;
            this.health = 5; this.maxHealth = 5; this.saltCount = 10;
            this.faceDir = [0, -1];
        }
        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, 2*Math.PI);
            ctx.fillStyle = SAFFRON;
            ctx.fill();
            ctx.strokeStyle = '#ffd966';
            ctx.lineWidth = 2;
            ctx.stroke();

            const barW = 40, barH = 6;
            ctx.fillStyle = '#8b0000';
            ctx.fillRect(this.x - barW/2, this.y - this.radius - 15, barW, barH);
            ctx.fillStyle = HEALTH_GREEN;
            ctx.fillRect(this.x - barW/2, this.y - this.radius - 15, barW * (this.health/this.maxHealth), barH);

            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(this.x + this.faceDir[0]*25, this.y + this.faceDir[1]*25);
            ctx.strokeStyle = WHITE;
            ctx.lineWidth = 3;
            ctx.stroke();
        }
        move(dx, dy) {
            if (dx !== 0 || dy !== 0) {
                let len = Math.hypot(dx, dy);
                this.faceDir = [dx/len, dy/len];
            }
            let newX = this.x + dx * this.speed;
            let newY = this.y + dy * this.speed;
            let playerRect = { x: newX - this.radius, y: newY - this.radius, w: this.radius*2, h: this.radius*2 };

            let canMoveX = true, canMoveY = true;
            for (let w of walls) {
                if (rectCollide(playerRect, w)) {
                    if (dx > 0 && playerRect.x + playerRect.w > w.x && newX - this.radius < w.x + w.w) {
                        if (playerRect.x + playerRect.w - w.x < 15) {
                            canMoveX = false;
                            newX = w.x - this.radius;
                        }
                    } else if (dx < 0 && playerRect.x < w.x + w.w && newX + this.radius > w.x) {
                        if (w.x + w.w - playerRect.x < 15) {
                            canMoveX = false;
                            newX = w.x + w.w + this.radius;
                        }
                    }
                    if (dy > 0 && playerRect.y + playerRect.h > w.y && newY - this.radius < w.y + w.h) {
                        if (playerRect.y + playerRect.h - w.y < 15) {
                            canMoveY = false;
                            newY = w.y - this.radius;
                        }
                    } else if (dy < 0 && playerRect.y < w.y + w.h && newY + this.radius > w.y) {
                        if (w.y + w.h - playerRect.y < 15) {
                            canMoveY = false;
                            newY = w.y + w.h + this.radius;
                        }
                    }
                }
            }
            if (canMoveX) this.x = newX;
            if (canMoveY) this.y = newY;
        }
        takeDamage(amount) { this.health = Math.max(0, this.health - amount); }
        heal(amount) { this.health = Math.min(this.maxHealth, this.health + amount); }
    }

    // Game Manager
    class Game {
        constructor() {
            this.player = new Player();
            this.blackGhosts = [];
            this.blueGhosts = [];
            this.redBosses = [];
            this.purpleBosses = [];
            this.salts = [];
            this.pickups = [];
            this.score = 0;
            this.state = 'playing';
            this.damageCooldown = 0;
            this.ghostSpawnTimer = 0;
            this.pickupSpawnTimer = 0;
            this.saltCooldown = 0;

            for (let i=0;i<3;i++) this.spawnGhost('black');
            for (let i=0;i<2;i++) this.spawnGhost('blue');
        }
        
        spawnGhost(type) {
            const totalGhosts = this.blackGhosts.length + this.blueGhosts.length;
            if (totalGhosts >= MAX_GHOSTS) return;
            
            let x = Math.random()*(WIDTH-100)+50, y = Math.random()*(HEIGHT-100)+50;
            if (type==='black') this.blackGhosts.push(new BlackGhost(x,y));
            else this.blueGhosts.push(new BlueGhost(x,y));
        }
        
        spawnPickup() {
            for (let a=0;a<100;a++) {
                let x = Math.random()*(WIDTH-100)+50, y = Math.random()*(HEIGHT-100)+50;
                let rect = {x:x-10,y:y-10,w:20,h:20};
                let valid = true;
                for (let w of walls) if (rectCollide(rect,w)) { valid=false; break; }
                if (valid) {
                    let type = Math.random()<0.7?'salt':'health';
                    this.pickups.push(new Pickup(x,y,type));
                    return;
                }
            }
        }
        
        spawnBoss(type, pos) {
            let x = pos?pos[0]:(Math.random()*(WIDTH-200)+100);
            let y = pos?pos[1]:(Math.random()*(HEIGHT-200)+100);
            if (type==='red') this.redBosses.push(new RedBoss(x,y));
            else this.purpleBosses.push(new PurpleBoss(x,y));
        }
        
        canThrowSalt() { return this.saltCooldown===0 && this.player.saltCount>0; }
        
        throwSalt(dx,dy) {
            if (this.canThrowSalt()) {
                this.salts.push(new SaltProjectile(this.player.x,this.player.y,dx,dy));
                this.player.saltCount--;
                this.saltCooldown = 15;
            }
        }
        
        update() {
            if (this.state==='game_over'||this.state==='victory') return;

            this.damageCooldown = Math.max(0,this.damageCooldown-1);
            this.saltCooldown = Math.max(0,this.saltCooldown-1);
            this.ghostSpawnTimer++;
            this.pickupSpawnTimer++;

            const totalGhosts = this.blackGhosts.length + this.blueGhosts.length;
            
            if (this.redBosses.length===0 && this.ghostSpawnTimer>=90) {
                this.ghostSpawnTimer=0;
                if (totalGhosts < MAX_GHOSTS) {
                    if (Math.random()<0.6) this.spawnGhost('black'); else this.spawnGhost('blue');
                }
            }
            
            if (this.pickupSpawnTimer>=180 && this.pickups.length<5) {
                this.pickupSpawnTimer=0; this.spawnPickup();
            }

            // Update ghosts
            for (let g of [...this.blackGhosts]) {
                g.update(this.player.x,this.player.y);
                if (g.checkCollision(this.player) && this.damageCooldown===0) {
                    this.player.takeDamage(g.damage); this.damageCooldown=30;
                    this.blackGhosts = this.blackGhosts.filter(x=>x!==g);
                    if (this.player.health<=0) this.state='game_over';
                }
            }
            for (let g of [...this.blueGhosts]) {
                g.update(this.player.x,this.player.y);
                if (g.checkCollision(this.player) && this.damageCooldown===0) {
                    this.player.takeDamage(g.damage); this.damageCooldown=30;
                    this.blueGhosts = this.blueGhosts.filter(x=>x!==g);
                    if (this.player.health<=0) this.state='game_over';
                }
            }

            // Update bosses
            for (let b of [...this.redBosses, ...this.purpleBosses]) {
                b.update(this.player.x,this.player.y);
                if (b.checkCollision(this.player) && this.damageCooldown===0) {
                    this.player.takeDamage(b.damage); this.damageCooldown=30;
                    if (this.player.health<=0) this.state='game_over';
                }
                if (b.canUseDust() && b.checkDustHit(this.player) && this.damageCooldown===0) {
                    this.player.takeDamage(b.dustDamage); this.damageCooldown=30;
                    b.useDust();
                    if (this.player.health<=0) this.state='game_over';
                }
            }

            // Update salts
            for (let s of [...this.salts]) {
                s.update();
                if (!s.active) { this.salts = this.salts.filter(x=>x!==s); continue; }
                
                for (let g of [...this.blackGhosts]) {
                    if (Math.hypot(s.x-g.x,s.y-g.y) < s.radius+g.radius) {
                        this.blackGhosts = this.blackGhosts.filter(x=>x!==g);
                        this.score += g.points;
                        s.active=false; this.salts = this.salts.filter(x=>x!==s); break;
                    }
                } if (!s.active) continue;
                
                for (let g of [...this.blueGhosts]) {
                    if (Math.hypot(s.x-g.x,s.y-g.y) < s.radius+g.radius) {
                        this.blueGhosts = this.blueGhosts.filter(x=>x!==g);
                        this.score += g.points;
                        s.active=false; this.salts = this.salts.filter(x=>x!==s); break;
                    }
                } if (!s.active) continue;
                
                for (let b of [...this.redBosses]) {
                    if (Math.hypot(s.x-b.x,s.y-b.y) < s.radius+b.radius) {
                        b.health--; s.active=false; this.salts = this.salts.filter(x=>x!==s);
                        if (b.health<=0) { this.redBosses = this.redBosses.filter(x=>x!==b); this.score += b.points; }
                        break;
                    }
                } if (!s.active) continue;
                
                for (let b of [...this.purpleBosses]) {
                    if (Math.hypot(s.x-b.x,s.y-b.y) < s.radius+b.radius) {
                        b.health--; s.active=false; this.salts = this.salts.filter(x=>x!==s);
                        if (b.health<=0) { this.purpleBosses = this.purpleBosses.filter(x=>x!==b); this.score += b.points; }
                        break;
                    }
                }
            }

            // Check pickups
            for (let p of [...this.pickups]) {
                if (p.checkCollision(this.player)) {
                    if (p.type==='salt') this.player.saltCount += Math.floor(Math.random()*3)+2;
                    else {
                        this.player.heal(1);
                        if (this.player.maxHealth<10 && Math.random()<0.3) { this.player.maxHealth++; this.player.heal(1); }
                    }
                    this.pickups = this.pickups.filter(x=>x!==p);
                }
            }

            // Boss spawn conditions
            if (this.score>=25 && this.redBosses.length===0 && this.purpleBosses.length===0) this.spawnBoss('red');
            if (this.score>=70 && this.purpleBosses.length===0) this.spawnBoss('purple');

            // Final round
            if (this.score>=101 && this.redBosses.length===0 && this.purpleBosses.length===0 && this.state==='playing') {
                this.state='final_round';
                const corners = [[100,100], [WIDTH-100,100], [WIDTH-100,HEIGHT-100]];
                let playerCorner = -1;
                for (let i=0;i<corners.length;i++) {
                    if (Math.hypot(this.player.x-corners[i][0], this.player.y-corners[i][1])<200) { playerCorner=i; break; }
                }
                let bossCount=0;
                for (let i=0;i<3;i++) {
                    if (i!==playerCorner || bossCount>=2) {
                        if (bossCount<2) this.spawnBoss('red', corners[i]);
                        else this.spawnBoss('purple', corners[i]);
                        bossCount++;
                    }
                }
            }

            if (this.state==='final_round' && this.purpleBosses.length===0) this.state='victory';
        }
        
        draw() {
            ctx.clearRect(0,0,WIDTH,HEIGHT);
            ctx.fillStyle=BACKGROUND; ctx.fillRect(0,0,WIDTH,HEIGHT);
            
            // Draw walls
            for (let w of walls) {
                ctx.fillStyle=WALL_COLOR; ctx.fillRect(w.x,w.y,w.w,w.h);
                ctx.strokeStyle=WALL_BORDER; ctx.lineWidth=2; ctx.strokeRect(w.x,w.y,w.w,w.h);
            }
            
            // Draw all game objects
            this.player.draw();
            for (let g of this.blackGhosts) g.draw();
            for (let g of this.blueGhosts) g.draw();
            for (let b of this.redBosses) b.draw();
            for (let b of this.purpleBosses) b.draw();
            for (let s of this.salts) s.draw();
            for (let p of this.pickups) p.draw();

            // Draw aim indicator for mobile (manual/mixed mode)
            if ((currentAimMode === 'manual' || currentAimMode === 'mixed') && 
                (game.state === 'playing' || game.state === 'final_round')) {
                
                // Draw aim line from player
                const aimLength = 50;
                ctx.beginPath();
                ctx.moveTo(this.player.x, this.player.y);
                ctx.lineTo(
                    this.player.x + aimDirection.x * aimLength,
                    this.player.y + aimDirection.y * aimLength
                );
                ctx.strokeStyle = 'rgba(255, 100, 255, 0.8)';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Draw aim circle at end
                ctx.beginPath();
                ctx.arc(
                    this.player.x + aimDirection.x * aimLength,
                    this.player.y + aimDirection.y * aimLength,
                    8, 0, 2*Math.PI
                );
                ctx.fillStyle = 'rgba(255, 100, 255, 0.3)';
                ctx.fill();
                ctx.strokeStyle = '#ff99ff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Draw state messages
            if (this.state==='final_round') {
                ctx.fillStyle='#ff4d4d'; ctx.font='bold 42px Arial'; ctx.textAlign='center';
                ctx.fillText('FINAL ROUND!',400,100);
                ctx.font='24px Arial'; ctx.fillStyle='#ccc';
                ctx.fillText(`Bosses left: ${this.redBosses.length+this.purpleBosses.length}`,400,150);
            } else if (this.state==='game_over') {
                ctx.fillStyle='rgba(0,0,0,0.7)'; ctx.fillRect(0,0,WIDTH,HEIGHT);
                ctx.fillStyle='#ff4d4d'; ctx.font='bold 52px Arial'; ctx.fillText('GAME OVER',400,280);
                ctx.font='28px Arial'; ctx.fillStyle='#eee'; ctx.fillText(`Score: ${this.score}`,400,360);
            } else if (this.state==='victory') {
                ctx.fillStyle='rgba(30,80,30,0.7)'; ctx.fillRect(0,0,WIDTH,HEIGHT);
                ctx.fillStyle='#b7ffb7'; ctx.font='bold 52px Arial'; ctx.fillText('VICTORY!',400,280);
                ctx.font='28px Arial'; ctx.fillStyle='#eee'; ctx.fillText(`Score: ${this.score}`,400,360);
            }

            // Draw warnings
            if (this.score>=23 && this.score<25 && this.redBosses.length===0) {
                ctx.fillStyle='#ffaaaa'; ctx.font='bold 24px Arial'; ctx.fillText('‚ö† Red Boss incoming at 25 ‚ö†',400,550);
            } else if (this.score>=68 && this.score<70 && this.purpleBosses.length===0) {
                ctx.fillStyle='#d9b3ff'; ctx.font='bold 24px Arial'; ctx.fillText('‚ö† Purple Boss incoming at 70 ‚ö†',400,550);
            }

            // Update UI
            scoreSpan.innerText = this.score;
            saltSpan.innerText = this.player.saltCount;
            healthSpan.innerText = `${this.player.health}/${this.player.maxHealth}`;
        }
    }

    // Joystick
    const base = document.getElementById('joystickBase');
    const thumb = document.getElementById('joystickThumb');
    let joystickActive = false;
    let joystickVector = { x:0, y:0 };

    function handleJoystickStart(e) {
        e.preventDefault();
        joystickActive = true;
    }
    
    function handleJoystickMove(e) {
        if (!joystickActive) return;
        e.preventDefault();
        const touch = e.touches ? e.touches[0] : e;
        const rect = base.getBoundingClientRect();
        const baseX = rect.left + rect.width/2;
        const baseY = rect.top + rect.height/2;
        const maxDist = rect.width/2 - 8;

        let dx = (touch.clientX - baseX) / maxDist;
        let dy = (touch.clientY - baseY) / maxDist;
        const dist = Math.hypot(dx, dy);
        if (dist > 1.0) { dx /= dist; dy /= dist; }
        joystickVector = { x: dx, y: dy };
        thumb.style.transform = `translate(${dx * maxDist}px, ${dy * maxDist}px)`;
    }
    
    function handleJoystickEnd(e) {
        e.preventDefault();
        joystickActive = false;
        joystickVector = { x:0, y:0 };
        thumb.style.transform = `translate(0px, 0px)`;
    }

    base.addEventListener('touchstart', handleJoystickStart, {passive:false});
    base.addEventListener('touchmove', handleJoystickMove, {passive:false});
    base.addEventListener('touchend', handleJoystickEnd);
    base.addEventListener('touchcancel', handleJoystickEnd);
    base.addEventListener('mousedown', handleJoystickStart);
    window.addEventListener('mousemove', (e) => { if (joystickActive) handleJoystickMove(e); });
    window.addEventListener('mouseup', handleJoystickEnd);

    // Keyboard
    let keys = {};
    window.addEventListener('keydown', (e) => {
        const key = e.key.toLowerCase();
        keys[key] = true;
        if (key==='r' && (game.state==='game_over'||game.state==='victory')) {
            game = new Game();
            restartBtn.classList.remove('visible');
        }
        if (['arrowup','arrowdown','arrowleft','arrowright','w','a','s','d',' '].includes(key)) e.preventDefault();
    });
    window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });

    // Space bar shooting
    window.addEventListener('keydown', (e) => {
        if (e.code === 'Space' && (game.state === 'playing' || game.state === 'final_round')) {
            e.preventDefault();
            let dx = game.player.faceDir[0];
            let dy = game.player.faceDir[1];
            if (dx === 0 && dy === 0) {
                dx = 0; dy = -1;
            }
            game.throwSalt(dx, dy);
        }
    });

    // Custom cursor (Desktop only, based on settings)
    let mouseX = -100, mouseY = -100;
    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        mouseX = (e.clientX - rect.left) * scaleX;
        mouseY = (e.clientY - rect.top) * scaleY;
    });
    canvas.addEventListener('mouseleave', () => { mouseX = -100; mouseY = -100; });

    // Override draw for custom cursor based on settings
    const origDraw = Game.prototype.draw;
    Game.prototype.draw = function() {
        origDraw.call(this);
        
        // Draw custom cursor for desktop based on settings
        if (mouseX >= 0 && mouseX < WIDTH && mouseY >= 0 && mouseY < HEIGHT) {
            if (currentCursorStyle === 'crosshair') {
                // Draw crosshair
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(mouseX - 15, mouseY);
                ctx.lineTo(mouseX - 5, mouseY);
                ctx.moveTo(mouseX + 5, mouseY);
                ctx.lineTo(mouseX + 15, mouseY);
                ctx.moveTo(mouseX, mouseY - 15);
                ctx.lineTo(mouseX, mouseY - 5);
                ctx.moveTo(mouseX, mouseY + 5);
                ctx.lineTo(mouseX, mouseY + 15);
                ctx.stroke();
                
                // Draw outer circle
                ctx.beginPath();
                ctx.arc(mouseX, mouseY, 8, 0, 2*Math.PI);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.stroke();
            } else if (currentCursorStyle === 'scope') {
                // Draw scope
                ctx.beginPath();
                ctx.arc(mouseX, mouseY, 12, 0, 2*Math.PI);
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(mouseX, mouseY, 4, 0, 2*Math.PI);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fill();
                
                // Cross lines
                ctx.beginPath();
                ctx.moveTo(mouseX - 18, mouseY);
                ctx.lineTo(mouseX - 12, mouseY);
                ctx.moveTo(mouseX + 12, mouseY);
                ctx.lineTo(mouseX + 18, mouseY);
                ctx.moveTo(mouseX, mouseY - 18);
                ctx.lineTo(mouseX, mouseY - 12);
                ctx.moveTo(mouseX, mouseY + 12);
                ctx.lineTo(mouseX, mouseY + 18);
                ctx.stroke();
            } else if (currentCursorStyle === 'dot') {
                // Simple dot
                ctx.beginPath();
                ctx.arc(mouseX, mouseY, 4, 0, 2*Math.PI);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.fill();
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            // 'none' does nothing
        }
    };

    // Game loop
    let game = new Game();
    restartBtn.addEventListener('click', () => {
        game = new Game();
        restartBtn.classList.remove('visible');
    });

    function gameLoop() {
        let dx = joystickVector.x, dy = joystickVector.y;
        if (dx === 0 && dy === 0) {
            if (keys['arrowleft']||keys['a']) dx = -1;
            if (keys['arrowright']||keys['d']) dx = 1;
            if (keys['arrowup']||keys['w']) dy = -1;
            if (keys['arrowdown']||keys['s']) dy = 1;
            if (dx !== 0 && dy !== 0) { dx *= 0.7071; dy *= 0.7071; }
        }
        
        if (game.state === 'playing' || game.state === 'final_round') {
            game.player.move(dx, dy);
        }

        game.update();
        game.draw();

        if (game.state === 'game_over' || game.state === 'victory') {
            restartBtn.classList.add('visible');
        } else {
            restartBtn.classList.remove('visible');
        }

        requestAnimationFrame(gameLoop);
    }
    gameLoop();

    canvas.addEventListener('contextmenu', e=>e.preventDefault());
})();
</script>
</body>
</html>
