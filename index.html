<!-- Ghost Hunter ‚Äì created by [REAL SPY/sanatani spy] (2026) -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GHOST HUNTER ¬∑ FINAL</title>
    <style>
        /* ===== RESET & BASE ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0718;
            font-family: 'Segoe UI', system-ui, sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        /* ===== PAGE CONTENT - THIS SCROLLS ===== */
        .page-wrapper {
            max-width: 1000px;
            width: 100%;
        }

        /* Header Section - ADD STUFF HERE */
        .header-content {
            background: linear-gradient(135deg, #6d28d9, #4c1d95);
            color: white;
            padding: 30px;
            border-radius: 30px;
            margin-bottom: 20px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(109, 40, 217, 0.5);
        }

        .header-content h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            text-shadow: 0 0 20px cyan;
        }

        /* Stats Bar - FIXED AT TOP OF GAME */
        .stats-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
            padding: 15px 25px;
            border-radius: 60px;
            margin-bottom: 20px;
            border: 2px solid #8b5cf6;
            color: white;
        }

        .stats {
            display: flex;
            gap: 30px;
        }

        .stat {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1.3rem;
            font-weight: bold;
        }

        .settings-btn {
            background: #8b5cf6;
            border: none;
            color: white;
            padding: 10px 25px;
            border-radius: 40px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            border: 2px solid white;
            transition: 0.2s;
        }

        .settings-btn:hover {
            transform: scale(1.05);
            background: #7c3aed;
        }

        /* ===== GAME CONTAINER - FIXED SIZE, NO SCROLL ===== */
        .game-container {
            position: relative;
            width: 100%;
            height: 600px; /* FIXED HEIGHT - GAME DOESN'T SCROLL */
            border-radius: 40px;
            overflow: hidden;
            border: 4px solid #8b5cf6;
            box-shadow: 0 20px 40px black;
            margin-bottom: 20px;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            background: #1a1035;
            cursor: none; /* We'll draw custom cursor */
        }

        /* Joystick - Only visible on touch devices */
        .joystick {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 100px;
            height: 100px;
            border-radius: 50px;
            background: rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border: 3px solid #8b5cf6;
            display: none; /* Hidden by default, shown on touch */
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .joystick.active {
            display: flex;
        }

        .joystick-thumb {
            width: 45px;
            height: 45px;
            background: radial-gradient(circle at 30% 30%, #fff, #8b5cf6);
            border-radius: 25px;
            border: 2px solid white;
            transition: transform 0.02s;
        }

        /* Fullscreen Button */
        .fullscreen-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 25px;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
            border: 3px solid #8b5cf6;
            color: white;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 10;
        }

        /* Restart Button */
        .restart-btn {
            background: linear-gradient(145deg, #6d28d9, #4c1d95);
            border: 3px solid #8b5cf6;
            color: white;
            font-size: 1.5rem;
            font-weight: bold;
            padding: 15px 50px;
            border-radius: 50px;
            cursor: pointer;
            margin: 20px 0;
            box-shadow: 0 10px 0 #2e1065;
            transition: 0.1s;
            display: none;
            width: fit-content;
            margin-left: auto;
            margin-right: auto;
        }

        .restart-btn.visible {
            display: block;
        }

        .restart-btn:active {
            transform: translateY(5px);
            box-shadow: 0 5px 0 #2e1065;
        }

        /* Bottom Content - ADD STUFF HERE (SCROLLS) */
        .bottom-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .info-card {
            background: rgba(139, 92, 246, 0.2);
            border: 2px solid #8b5cf6;
            border-radius: 30px;
            padding: 20px;
            color: white;
            text-align: center;
            backdrop-filter: blur(5px);
        }

        .info-card h3 {
            color: #c4b5fd;
            margin-bottom: 10px;
            font-size: 1.3rem;
        }

        /* Settings Modal */
        .settings-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(10px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .settings-modal.show {
            display: flex;
        }

        .settings-content {
            background: linear-gradient(145deg, #1e1a3a, #0f0b20);
            border: 4px solid #8b5cf6;
            border-radius: 50px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .settings-header {
            color: white;
            font-size: 2rem;
            text-align: center;
            margin-bottom: 20px;
        }

        .setting-group {
            margin-bottom: 30px;
        }

        .setting-label {
            color: #c4b5fd;
            font-size: 1.2rem;
            margin-bottom: 10px;
            text-align: center;
        }

        .setting-options {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .setting-option {
            flex: 1;
            min-width: 100px;
            padding: 15px;
            background: rgba(255,255,255,0.1);
            border: 2px solid transparent;
            border-radius: 30px;
            color: white;
            text-align: center;
            cursor: pointer;
            transition: 0.2s;
        }

        .setting-option:hover {
            background: rgba(139, 92, 246, 0.3);
        }

        .setting-option.selected {
            background: #8b5cf6;
            border-color: white;
        }

        .close-btn {
            background: #ef4444;
            color: white;
            border: none;
            padding: 15px;
            border-radius: 40px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            width: 100%;
            margin-top: 20px;
            border: 2px solid white;
        }

        /* Rotation Warning */
        .rotate-warning {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0718;
            display: none;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 2rem;
            text-align: center;
            z-index: 2000;
            flex-direction: column;
        }

        .rotate-warning.show {
            display: flex;
        }

        @media (max-width: 768px) {
            .stats { gap: 15px; }
            .stat { font-size: 1rem; }
            .joystick.active { display: flex; }
        }
    </style>
</head>
<body>
    <!-- Rotation Warning -->
    <div class="rotate-warning" id="rotateWarning">
        <div style="font-size: 5rem; margin-bottom: 20px;">üîÑ</div>
        <h1>Please Rotate to Landscape</h1>
        <p style="margin-top: 20px;">This game works best in landscape mode</p>
    </div>

    <!-- Settings Modal (Aim options removed) -->
    <div class="settings-modal" id="settingsModal">
        <div class="settings-content">
            <div class="settings-header">‚öôÔ∏è SETTINGS</div>
            
            <div class="setting-group">
                <div class="setting-label">DIFFICULTY</div>
                <div class="setting-options">
                    <div class="setting-option" onclick="setDifficulty('easy')" id="diffEasy">EASY</div>
                    <div class="setting-option selected" onclick="setDifficulty('medium')" id="diffMedium">MEDIUM</div>
                    <div class="setting-option" onclick="setDifficulty('hard')" id="diffHard">HARD</div>
                </div>
            </div>

            <div class="setting-group">
                <div class="setting-label">CURSOR</div>
                <div class="setting-options">
                    <div class="setting-option selected" onclick="setCursor('cross')" id="curCross">CROSS</div>
                    <div class="setting-option" onclick="setCursor('dot')" id="curDot">DOT</div>
                    <div class="setting-option" onclick="setCursor('none')" id="curNone">NONE</div>
                </div>
            </div>

            <button class="close-btn" onclick="closeSettings()">CLOSE</button>
        </div>
    </div>

    <!-- PAGE WRAPPER - THIS SCROLLS -->
    <div class="page-wrapper">
        <!-- HEADER SECTION - ADD YOUR STUFF HERE -->
        <div class="header-content">
            <h1>üëª GHOST HUNTER</h1>
            <p>The ultimate ghost hunting experience</p>
            <!-- Add images, banners, anything here -->
        </div>

        <!-- STATS BAR - FIXED ABOVE GAME -->
        <div class="stats-bar">
            <div class="stats">
                <div class="stat"><span>üèÜ</span> <span id="score">0</span></div>
                <div class="stat"><span>üßÇ</span> <span id="salt">10</span></div>
                <div class="stat"><span>‚ù§Ô∏è</span> <span id="health">5/10</span></div>
            </div>
            <button class="settings-btn" onclick="openSettings()">‚öôÔ∏è SETTINGS</button>
        </div>

        <!-- GAME CONTAINER - FIXED SIZE, DOESN'T SCROLL -->
        <div class="game-container">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            
            <!-- Joystick (mobile only) -->
            <div class="joystick" id="joystick">
                <div class="joystick-thumb" id="joystickThumb"></div>
            </div>

            <!-- Fullscreen Button -->
            <div class="fullscreen-btn" onclick="toggleFullscreen()">‚õ∂</div>
        </div>

        <!-- RESTART BUTTON -->
        <button class="restart-btn" id="restartBtn" onclick="restartGame()">‚Üª PLAY AGAIN</button>

        <!-- BOTTOM CONTENT - ADD YOUR STUFF HERE (SCROLLS) -->
        <div class="bottom-content">
            <div class="info-card">
                <h3>üëª BLACK GHOST</h3>
                <p>Speed: Normal<br>Points: 1</p>
            </div>
            <div class="info-card">
                <h3>üí® BLUE GHOST</h3>
                <p>Speed: Fast<br>Points: 2</p>
            </div>
            <div class="info-card">
                <h3>üëë RED BOSS</h3>
                <p>Health: 10<br>Points: 10</p>
            </div>
            <div class="info-card">
                <h3>üëæ PURPLE BOSS</h3>
                <p>Health: 15-20<br>Points: 20</p>
            </div>
            <!-- Add images, guides, anything here -->
        </div>
    </div>

    <script>
        // ========== SETTINGS SYSTEM (simplified) ==========
        let currentDifficulty = 'medium';
        let currentCursor = 'cross';
        let game;

        window.openSettings = function() {
            document.getElementById('settingsModal').classList.add('show');
        };

        window.closeSettings = function() {
            document.getElementById('settingsModal').classList.remove('show');
        };

        window.setDifficulty = function(level) {
            currentDifficulty = level;
            ['Easy', 'Medium', 'Hard'].forEach(d => {
                document.getElementById(`diff${d}`).classList.remove('selected');
            });
            document.getElementById(`diff${level.charAt(0).toUpperCase() + level.slice(1)}`).classList.add('selected');
            if (game) restartGame();
        };

        window.setCursor = function(style) {
            currentCursor = style;
            ['Cross', 'Dot', 'None'].forEach(c => {
                document.getElementById(`cur${c}`).classList.remove('selected');
            });
            document.getElementById(`cur${style.charAt(0).toUpperCase() + style.slice(1)}`).classList.add('selected');
        };

        // ========== FULLSCREEN ==========
        window.toggleFullscreen = function() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        };

        // ========== ROTATION WARNING ==========
        function checkOrientation() {
            const warning = document.getElementById('rotateWarning');
            if (window.innerHeight > window.innerWidth) {
                warning.classList.add('show');
            } else {
                warning.classList.remove('show');
            }
        }
        window.addEventListener('resize', checkOrientation);
        window.addEventListener('orientationchange', checkOrientation);
        checkOrientation();

        // ========== SHOW JOYSTICK ON TOUCH DEVICES ==========
        if ('ontouchstart' in window) {
            document.getElementById('joystick').classList.add('active');
        }

        // ========== GAME CONSTANTS ==========
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const WIDTH = 800, HEIGHT = 600;

        // Difficulty multipliers - FASTER
        const DIFFICULTY = {
            easy: 1.0,
            medium: 1.5,
            hard: 2.0
        };

        // MAP SYSTEM
        const MAPS = {
            classic: {
                walls: [
                    { x: 0, y: 0, w: 800, h: 20 },
                    { x: 0, y: 580, w: 800, h: 20 },
                    { x: 0, y: 0, w: 20, h: 600 },
                    { x: 780, y: 0, w: 20, h: 600 },
                    { x: 200, y: 20, w: 20, h: 400 },
                    { x: 400, y: 180, w: 20, h: 400 },
                    { x: 600, y: 20, w: 20, h: 400 }
                ],
                background: '#1a1035'
            }
        };

        let currentMap = MAPS.classic;

        // ========== PLAYER CLASS with FIXED COLLISION ==========
        class Player {
            constructor() {
                this.x = 100;
                this.y = 100;
                this.radius = 18;
                this.speed = 5;
                this.health = 5;
                this.maxHealth = 10;          // Changed from 5 to 10
                this.salt = 10;
                this.facing = { x: 0, y: -1 };
            }

            // Robust collision resolution: separate axes + iteration
            move(dx, dy) {
                if (dx !== 0 || dy !== 0) {
                    const len = Math.hypot(dx, dy);
                    this.facing = { x: dx/len, y: dy/len };
                }

                let newX = this.x + dx * this.speed;
                let newY = this.y + dy * this.speed;

                // Iterative collision resolution (max 10 iterations to prevent infinite loops)
                const maxIter = 10;
                for (let iter = 0; iter < maxIter; iter++) {
                    let collided = false;
                    
                    // Check all walls for collision with the proposed new position
                    for (let w of currentMap.walls) {
                        // Check if circle (player) collides with AABB (wall)
                        const closestX = Math.max(w.x, Math.min(newX, w.x + w.w));
                        const closestY = Math.max(w.y, Math.min(newY, w.y + w.h));
                        const dx = newX - closestX;
                        const dy = newY - closestY;
                        const dist = Math.hypot(dx, dy);
                        
                        if (dist < this.radius) {
                            // Collision detected - push out
                            collided = true;
                            if (dist === 0) {
                                // Rare case: exactly at center ‚Äì push in a default direction
                                newX = w.x + w.w + this.radius;
                                newY = w.y + w.h + this.radius;
                                break;
                            } else {
                                // Push out along the normal
                                const overlap = this.radius - dist;
                                const nx = dx / dist;
                                const ny = dy / dist;
                                newX += nx * overlap;
                                newY += ny * overlap;
                            }
                            // After adjusting, break out of wall loop to re-check all walls
                            break;
                        }
                    }
                    
                    if (!collided) break; // No more collisions, done
                }

                // Final bounds clamping
                this.x = Math.max(this.radius, Math.min(WIDTH - this.radius, newX));
                this.y = Math.max(this.radius, Math.min(HEIGHT - this.radius, newY));
            }

            draw() {
                // Player
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#ff9933';
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Health bar
                const barWidth = 40;
                const barHeight = 6;
                ctx.fillStyle = '#8b0000';
                ctx.fillRect(this.x - barWidth/2, this.y - this.radius - 15, barWidth, barHeight);
                ctx.fillStyle = '#2ecc71';
                ctx.fillRect(this.x - barWidth/2, this.y - this.radius - 15, 
                           barWidth * (this.health / this.maxHealth), barHeight);

                // Direction line
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x + this.facing.x * 25, this.y + this.facing.y * 25);
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        // ========== GHOST CLASS ==========
        class Ghost {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                
                if (type === 'black') {
                    this.radius = 15;
                    this.speed = 2.0 * DIFFICULTY[currentDifficulty];
                    this.damage = 1;
                    this.points = 1;
                    this.color = '#222222';
                } else {
                    this.radius = 12;
                    this.speed = 3.2 * DIFFICULTY[currentDifficulty];
                    this.damage = 0.5;
                    this.points = 2;
                    this.color = '#3a7bd5';
                }
            }

            update(player) {
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.hypot(dx, dy) || 1;
                this.x += (dx / dist) * this.speed;
                this.y += (dy / dist) * this.speed;
                
                this.x = Math.max(this.radius, Math.min(WIDTH - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(HEIGHT - this.radius, this.y));
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                
                // Eyes
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(this.x - 5, this.y - 5, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(this.x + 5, this.y - 5, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            checkCollision(player) {
                const dx = this.x - player.x;
                const dy = this.y - player.y;
                return Math.hypot(dx, dy) < this.radius + player.radius;
            }
        }

        // ========== BOSS CLASS ==========
        class Boss {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                
                if (type === 'red') {
                    this.radius = 35;
                    this.speed = 1.5 * DIFFICULTY[currentDifficulty];
                    this.damage = 1;
                    this.health = 10;
                    this.maxHealth = 10;
                    this.points = 10;
                    this.color = '#e63946';
                } else {
                    this.radius = 40;
                    this.speed = 1.8 * DIFFICULTY[currentDifficulty];
                    this.damage = 1;
                    this.health = Math.floor(Math.random() * 6) + 15;
                    this.maxHealth = this.health;
                    this.points = 20;
                    this.color = '#9d4edd';
                }
                
                this.dustCooldown = 120;
                this.dustTimer = Math.random() * 120;
            }

            update(player) {
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.hypot(dx, dy) || 1;
                this.x += (dx / dist) * this.speed;
                this.y += (dy / dist) * this.speed;
                this.dustTimer++;
                
                this.x = Math.max(this.radius, Math.min(WIDTH - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(HEIGHT - this.radius, this.y));
            }

            draw() {
  	  ctx.beginPath();
 	   ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
   	 ctx.fillStyle = this.color;
   	 ctx.fill();

  	  // Crown
    	ctx.fillStyle = '#ffd966';
    	ctx.beginPath();
   	 ctx.moveTo(this.x - 25, this.y - this.radius - 5);
   	 ctx.lineTo(this.x - 15, this.y - this.radius - 15);
  	  ctx.lineTo(this.x, this.y - this.radius - 20);
 	   ctx.lineTo(this.x + 15, this.y - this.radius - 15);
   	 ctx.lineTo(this.x + 25, this.y - this.radius - 5);
   	 ctx.closePath();
   	 ctx.fill();

  	  // Health bar
  	  const barW = 60, barH = 8;
    	ctx.fillStyle = '#330000';
    	ctx.fillRect(this.x - barW/2, this.y - this.radius - 25, barW, barH);
    	ctx.fillStyle = '#e63946';
    	ctx.fillRect(this.x - barW/2, this.y - this.radius - 25, 
            	   barW * (this.health / this.maxHealth), barH);

    // ========== DUST WARNING RING ==========
    const framesUntilDust = this.dustCooldown - this.dustTimer;
    if (framesUntilDust < 30 && framesUntilDust > 0) {
        // Pulsing transparency: more opaque as it gets closer
        const alpha = 0.3 + 0.7 * (1 - framesUntilDust / 30);
        // Subtle pulse in radius
        const pulse = 1 + 0.05 * Math.sin(Date.now() * 0.02);
        const ringRadius = 150 * pulse;

        ctx.beginPath();
        ctx.arc(this.x, this.y, ringRadius, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(255, 100, 100, ${alpha})`;
        ctx.lineWidth = 4;
        ctx.stroke();

        // Optional semi‚Äëtransparent fill
        ctx.fillStyle = `rgba(255, 0, 0, ${alpha * 0.15})`;
        ctx.fill();
    } else if (this.dustTimer >= this.dustCooldown) {
        // Fully charged ‚Äì solid red ring
        ctx.beginPath();
        ctx.arc(this.x, this.y, 150, 0, Math.PI * 2);
        ctx.strokeStyle = '#ff0000';
        ctx.lineWidth = 6;
        ctx.stroke();
    }
    // ========================================
}

            checkCollision(player) {
                const dx = this.x - player.x;
                const dy = this.y - player.y;
                return Math.hypot(dx, dy) < this.radius + player.radius;
            }

            canUseDust() {
                return this.dustTimer >= this.dustCooldown;
            }

            useDust() {
                this.dustTimer = 0;
            }

            checkDustHit(player) {
                const dx = this.x - player.x;
                const dy = this.y - player.y;
                return Math.hypot(dx, dy) < 150;
            }
        }

        // ========== SALT CLASS ==========
        class Salt {
            constructor(x, y, dx, dy) {
                this.x = x;
                this.y = y;
                this.dx = dx;
                this.dy = dy;
                this.radius = 5;
                this.speed = 8;
                this.active = true;
            }

            update() {
                this.x += this.dx * this.speed;
                this.y += this.dy * this.speed;
                if (this.x < -50 || this.x > WIDTH + 50 || this.y < -50 || this.y > HEIGHT + 50) {
                    this.active = false;
                }
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#e0e0ff';
                ctx.fill();
            }
        }

        // ========== PICKUP CLASS ==========
        class Pickup {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.radius = 10;
                this.type = type;
                this.color = type === 'salt' ? '#e0e0ff' : '#2ecc71';
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.type === 'salt' ? 'S' : '+', this.x, this.y);
            }

            checkCollision(player) {
                const dx = this.x - player.x;
                const dy = this.y - player.y;
                return Math.hypot(dx, dy) < this.radius + player.radius;
            }
        }

        // ========== GAME MANAGER ==========
        class Game {
            constructor() {
                this.player = new Player();
                this.blackGhosts = [];
                this.blueGhosts = [];
                this.redBosses = [];
                this.purpleBosses = [];
                this.salts = [];
                this.pickups = [];
                this.score = 0;
                this.state = 'playing';
                this.damageCooldown = 0;
                this.saltCooldown = 0;
                this.spawnTimer = 0;
                this.pickupSpawnTimer = 0;
            }

            // Spawn a pickup at a random valid location
            spawnPickup() {
                // Try up to 100 times to find a valid position
                for (let attempts = 0; attempts < 100; attempts++) {
                    const x = Math.random() * (WIDTH - 100) + 50;
                    const y = Math.random() * (HEIGHT - 100) + 50;
                    
                    // Check if position is inside any wall
                    let valid = true;
                    for (let w of currentMap.walls) {
                        // Simple AABB check (with some margin)
                        if (x > w.x - 15 && x < w.x + w.w + 15 &&
                            y > w.y - 15 && y < w.y + w.h + 15) {
                            valid = false;
                            break;
                        }
                    }
                    
                    if (valid) {
                        // 5:3 ratio salt:health (62.5% salt, 37.5% health)
                        const type = Math.random() < 5/8 ? 'salt' : 'health';
                        this.pickups.push(new Pickup(x, y, type));
                        return;
                    }
                }
            }

            update() {
                if (this.state !== 'playing' && this.state !== 'final_round') return;

                // Cooldowns
                this.damageCooldown = Math.max(0, this.damageCooldown - 1);
                this.saltCooldown = Math.max(0, this.saltCooldown - 1);
                this.spawnTimer++;
                this.pickupSpawnTimer++;

                // Spawn ghosts (NEW LOGIC: opposite side / random mix)
                // Spawn ghosts only if no bosses are alive


	if (this.spawnTimer >= 90 && 
  	  this.blackGhosts.length + this.blueGhosts.length < 8 &&
  	  this.redBosses.length === 0 && this.purpleBosses.length === 0) {
    
   	 this.spawnTimer = 0;
    
 	   const type = Math.random() < 0.6 ? 'black' : 'blue';
 	   let spawnX, spawnY;
  	  let attempts = 0;
  	  const maxAttempts = 10;
  	  let validPosition = false;

  	  while (!validPosition && attempts < maxAttempts) {
     	   // Decide spawn logic: 70% opposite side, 30% fully random
     	   if (Math.random() < 0.7) {
         	   // Opposite side relative to player
         	   if (this.player.x < 400) {
         	       spawnX = 400 + Math.random() * 350; // right half (400-750)
        	    } else {
         	       spawnX = 50 + Math.random() * 350;  // left half (50-400)
         	   }
        	    if (this.player.y < 300) {
          	      spawnY = 300 + Math.random() * 250; // bottom half (300-550)
          	  } else {
     	           spawnY = 50 + Math.random() * 250;  // top half (50-300)
      	      }
    	    } else {
     	       // Completely random
       	     spawnX = 50 + Math.random() * 700;
      	      spawnY = 50 + Math.random() * 500;
     	   }

	        // Simple wall check: ensure not inside any wall
    	    validPosition = true;
    	    for (let w of currentMap.walls) {
       	     if (spawnX > w.x - 20 && spawnX < w.x + w.w + 20 &&
      	          spawnY > w.y - 20 && spawnY < w.y + w.h + 20) {
            	    validPosition = false;
            	    break;
	            }
	        }
	        attempts++;
	    }

	    // Fallback if no valid position found
	    if (!validPosition) {
	        spawnX = 400;
	        spawnY = 300;
	    }

	    if (type === 'black') {
	        this.blackGhosts.push(new Ghost(spawnX, spawnY, 'black'));
	    } else {
	        this.blueGhosts.push(new Ghost(spawnX, spawnY, 'blue'));
	    }
	}

                // Spawn pickups (every 3 seconds, max 8 on screen)
                if (this.pickupSpawnTimer >= 180 && this.pickups.length < 8) {   // Changed from 5 to 8
                    this.pickupSpawnTimer = 0;
                    this.spawnPickup();
                }

                // Update ghosts
                [...this.blackGhosts, ...this.blueGhosts].forEach(ghost => {
                    ghost.update(this.player);
                    
                    if (ghost.checkCollision(this.player) && this.damageCooldown === 0) {
                        this.player.health -= ghost.damage;
                        this.damageCooldown = 30;
                        
                        if (ghost.type === 'black') {
                            this.blackGhosts = this.blackGhosts.filter(g => g !== ghost);
                        } else {
                            this.blueGhosts = this.blueGhosts.filter(g => g !== ghost);
                        }
                        
                        if (this.player.health <= 0) this.state = 'game_over';
                    }
                });

                // Update bosses
                [...this.redBosses, ...this.purpleBosses].forEach(boss => {
                    boss.update(this.player);
                    
                    if (boss.checkCollision(this.player) && this.damageCooldown === 0) {
                        this.player.health -= boss.damage;
                        this.damageCooldown = 30;
                        if (this.player.health <= 0) this.state = 'game_over';
                    }
                    
                    if (boss.canUseDust() && boss.checkDustHit(this.player) && this.damageCooldown === 0) {
                        this.player.health -= 1.5;
                        this.damageCooldown = 30;
                        boss.useDust();
                        if (this.player.health <= 0) this.state = 'game_over';
                    }
                });

                // Update salts
                this.salts = this.salts.filter(salt => {
                    salt.update();
                    if (!salt.active) return false;

                    // Check black ghosts
                    for (let ghost of [...this.blackGhosts]) {
                        if (Math.hypot(salt.x - ghost.x, salt.y - ghost.y) < salt.radius + ghost.radius) {
                            this.blackGhosts = this.blackGhosts.filter(g => g !== ghost);
                            this.score += ghost.points;
                            this.trySpawnPickup(ghost.x, ghost.y);
                            return false;
                        }
                    }

                    // Check blue ghosts
                    for (let ghost of [...this.blueGhosts]) {
                        if (Math.hypot(salt.x - ghost.x, salt.y - ghost.y) < salt.radius + ghost.radius) {
                            this.blueGhosts = this.blueGhosts.filter(g => g !== ghost);
                            this.score += ghost.points;
                            this.trySpawnPickup(ghost.x, ghost.y);
                            return false;
                        }
                    }

                    // Check bosses
                    for (let boss of [...this.redBosses, ...this.purpleBosses]) {
                        if (Math.hypot(salt.x - boss.x, salt.y - boss.y) < salt.radius + boss.radius) {
                            boss.health--;
                            if (boss.health <= 0) {
                                if (boss.type === 'red') {
                                    this.redBosses = this.redBosses.filter(b => b !== boss);
                                } else {
                                    this.purpleBosses = this.purpleBosses.filter(b => b !== boss);
                                }
                                this.score += boss.points;
                                this.trySpawnPickup(boss.x, boss.y);
                            }
                            return false;
                        }
                    }

                    return true;
                });

                // Check pickups (player collects them)
                this.pickups = this.pickups.filter(pickup => {
                    if (pickup.checkCollision(this.player)) {
                        if (pickup.type === 'salt') {
                            // Salt: random 1-4 (changed from 2-5)
                            this.player.salt += Math.floor(Math.random() * 4) + 1;
                        } else { // health
                            this.player.health = Math.min(this.player.maxHealth, this.player.health + 1);
                        }
                        return false; // remove pickup
                    }
                    return true;
                });

                // Boss spawns
                if (this.score >= 25 && this.redBosses.length === 0 && this.purpleBosses.length === 0) {
                    this.redBosses.push(new Boss(400, 300, 'red'));
                }
                if (this.score >= 70 && this.purpleBosses.length === 0) {
                    this.purpleBosses.push(new Boss(400, 300, 'purple'));
                }

                // Final round
                if (this.score >= 101 && this.redBosses.length === 0 && this.purpleBosses.length === 0 && this.state === 'playing') {
                    this.state = 'final_round';
                    this.redBosses.push(new Boss(200, 200, 'red'));
                    this.redBosses.push(new Boss(600, 200, 'red'));
                    this.purpleBosses.push(new Boss(400, 400, 'purple'));
                }

                // Victory (FIXED: check both boss arrays)
                if (this.state === 'final_round' && this.redBosses.length === 0 && this.purpleBosses.length === 0) {
                    this.state = 'victory';
                }

                // Update UI
                document.getElementById('score').textContent = this.score;
                document.getElementById('salt').textContent = this.player.salt;
                document.getElementById('health').textContent = `${this.player.health}/${this.player.maxHealth}`;
            }

            // Try to spawn a pickup at a given position (40% chance)
            trySpawnPickup(x, y) {
                if (Math.random() > 0.4) return;
                // Same 5:3 ratio for enemy drops
                const type = Math.random() < 5/8 ? 'salt' : 'health';
                this.pickups.push(new Pickup(x, y, type));
            }

            draw() {
                // Clear
                ctx.fillStyle = currentMap.background;
                ctx.fillRect(0, 0, WIDTH, HEIGHT);

                // Draw walls
                ctx.fillStyle = '#4b3b6b';
                currentMap.walls.forEach(w => ctx.fillRect(w.x, w.y, w.w, w.h));

                // Draw game objects
                this.player.draw();
                this.blackGhosts.forEach(g => g.draw());
                this.blueGhosts.forEach(g => g.draw());
                this.redBosses.forEach(b => b.draw());
                this.purpleBosses.forEach(b => b.draw());
                this.salts.forEach(s => s.draw());
                this.pickups.forEach(p => p.draw());

                // Game state messages
                if (this.state === 'final_round') {
                    ctx.fillStyle = '#ff4d4d';
                    ctx.font = 'bold 42px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('FINAL ROUND!', 400, 100);
                } else if (this.state === 'game_over') {
                    ctx.fillStyle = 'rgba(0,0,0,0.7)';
                    ctx.fillRect(0, 0, WIDTH, HEIGHT);
                    ctx.fillStyle = '#ff4d4d';
                    ctx.font = 'bold 52px Arial';
                    ctx.fillText('GAME OVER', 400, 300);
                } else if (this.state === 'victory') {
                    ctx.fillStyle = 'rgba(46,204,113,0.7)';
                    ctx.fillRect(0, 0, WIDTH, HEIGHT);
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 52px Arial';
                    ctx.fillText('VICTORY!', 400, 300);
                }
            }

            throwSalt(dx, dy) {
                if (this.saltCooldown === 0 && this.player.salt > 0) {
                    this.salts.push(new Salt(this.player.x, this.player.y, dx, dy));
                    this.player.salt--;
                    this.saltCooldown = 15;
                }
            }
        }

        // ========== CONTROLS ==========
        game = new Game();
        let keys = {};
        let mouseX = -1, mouseY = -1;
        let joystickActive = false;
        let joystickVector = { x: 0, y: 0 };

        // Keyboard
        window.addEventListener('keydown', e => {
            const key = e.key.toLowerCase();
            keys[key] = true;
            if (key === 'r' && (game.state === 'game_over' || game.state === 'victory')) restartGame();
            if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', 'w', 'a', 's', 'd', ' '].includes(key)) e.preventDefault();
        });

        window.addEventListener('keyup', e => {
            keys[e.key.toLowerCase()] = false;
        });

        // Space shoot
        window.addEventListener('keydown', e => {
            if (e.code === 'Space' && (game.state === 'playing' || game.state === 'final_round')) {
                e.preventDefault();
                game.throwSalt(game.player.facing.x, game.player.facing.y);
            }
        });

        // Mouse move (for cursor)
        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            mouseX = (e.clientX - rect.left) * scaleX;
            mouseY = (e.clientY - rect.top) * scaleY;
        });

        canvas.addEventListener('mouseleave', () => {
            mouseX = -1;
            mouseY = -1;
        });

        // Mouse click shoot
        canvas.addEventListener('click', e => {
            if (game.state !== 'playing' && game.state !== 'final_round') return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            
            const dx = x - game.player.x;
            const dy = y - game.player.y;
            const len = Math.hypot(dx, dy) || 1;
            game.throwSalt(dx/len, dy/len);
        });

        // Touch controls
        const joystick = document.getElementById('joystick');
        const joystickThumb = document.getElementById('joystickThumb');

        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            if (game.state !== 'playing' && game.state !== 'final_round') return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            for (let touch of e.touches) {
                // Check if on joystick
                const touchX = touch.clientX;
                const touchY = touch.clientY;
                const joystickRect = joystick.getBoundingClientRect();
                
                if (touchX >= joystickRect.left && touchX <= joystickRect.right &&
                    touchY >= joystickRect.top && touchY <= joystickRect.bottom) {
                    joystickActive = true;
                } else {
                    // Shoot
                    const canvasX = (touchX - rect.left) * scaleX;
                    const canvasY = (touchY - rect.top) * scaleY;
                    
                    const dx = canvasX - game.player.x;
                    const dy = canvasY - game.player.y;
                    const len = Math.hypot(dx, dy) || 1;
                    game.throwSalt(dx/len, dy/len);
                }
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if (!joystickActive) return;

            const touch = e.touches[0];
            const joystickRect = joystick.getBoundingClientRect();
            const centerX = joystickRect.left + joystickRect.width / 2;
            const centerY = joystickRect.top + joystickRect.height / 2;
            const maxDist = joystickRect.width / 2 - 10;

            let dx = (touch.clientX - centerX) / maxDist;
            let dy = (touch.clientY - centerY) / maxDist;
            const dist = Math.hypot(dx, dy);
            
            if (dist > 1) {
                dx /= dist;
                dy /= dist;
            }
            
            joystickVector = { x: dx, y: dy };
            joystickThumb.style.transform = `translate(${dx * maxDist}px, ${dy * maxDist}px)`;
        }, { passive: false });

        canvas.addEventListener('touchend', e => {
            e.preventDefault();
            joystickActive = false;
            joystickVector = { x: 0, y: 0 };
            joystickThumb.style.transform = 'translate(0px, 0px)';
        });

        canvas.addEventListener('touchcancel', e => {
            e.preventDefault();
            joystickActive = false;
            joystickVector = { x: 0, y: 0 };
            joystickThumb.style.transform = 'translate(0px, 0px)';
        });

        // ========== CURSOR DRAWING ==========
        const originalDraw = Game.prototype.draw;
        Game.prototype.draw = function() {
            originalDraw.call(this);
            
            // Draw custom cursor
            if (mouseX >= 0 && mouseX < WIDTH && mouseY >= 0 && mouseY < HEIGHT && currentCursor !== 'none') {
                if (currentCursor === 'cross') {
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(mouseX - 15, mouseY);
                    ctx.lineTo(mouseX - 5, mouseY);
                    ctx.moveTo(mouseX + 5, mouseY);
                    ctx.lineTo(mouseX + 15, mouseY);
                    ctx.moveTo(mouseX, mouseY - 15);
                    ctx.lineTo(mouseX, mouseY - 5);
                    ctx.moveTo(mouseX, mouseY + 5);
                    ctx.lineTo(mouseX, mouseY + 15);
                    ctx.stroke();
                } else if (currentCursor === 'dot') {
                    ctx.beginPath();
                    ctx.arc(mouseX, mouseY, 4, 0, Math.PI * 2);
                    ctx.fillStyle = 'white';
                    ctx.fill();
                }
            }
        };

        // ========== GAME LOOP ==========
        window.restartGame = function() {
            game = new Game();
            document.getElementById('restartBtn').classList.remove('visible');
            closeSettings();  // close settings modal if open
        };

        function gameLoop() {
            // Handle movement
            let dx = joystickVector.x;
            let dy = joystickVector.y;
            
            if (dx === 0 && dy === 0) {
                if (keys['arrowleft'] || keys['a']) dx = -1;
                if (keys['arrowright'] || keys['d']) dx = 1;
                if (keys['arrowup'] || keys['w']) dy = -1;
                if (keys['arrowdown'] || keys['s']) dy = 1;
                if (dx !== 0 && dy !== 0) {
                    dx *= 0.707;
                    dy *= 0.707;
                }
            }

            if (game.state === 'playing' || game.state === 'final_round') {
                game.player.move(dx, dy);
            }

            game.update();
            game.draw();

            if (game.state === 'game_over' || game.state === 'victory') {
                document.getElementById('restartBtn').classList.add('visible');
            }

            requestAnimationFrame(gameLoop);
        }

        gameLoop();

        // Prevent context menu
        canvas.addEventListener('contextmenu', e => e.preventDefault());
    </script>
</body>
</html>
